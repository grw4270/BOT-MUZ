// ===============================
// Discord Music Bot (YouTube/Spotify via play-dl)
// ===============================

// 1️⃣ Ładowanie bibliotek
require('dotenv').config();
const { Client, GatewayIntentBits, Partials } = require('discord.js');
const {
  joinVoiceChannel,
  createAudioPlayer,
  createAudioResource,
  AudioPlayerStatus,
  NoSubscriberBehavior,
  getVoiceConnection,
  generateDependencyReport
} = require('@discordjs/voice');
const play = require('play-dl');

// 2️⃣ Konfiguracja prefixa i tokena
const PREFIX = process.env.PREFIX || '!';
const TOKEN = process.env.DISCORD_TOKEN;

if (!TOKEN) {
  console.error('❌ Brakuje DISCORD_TOKEN w pliku .env!');
  process.exit(1);
}

// 3️⃣ Inicjalizacja klienta Discord
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildVoiceStates
  ],
  partials: [Partials.Channel]
});

// 4️⃣ Map kolejki
const queues = new Map();

/**
 * Struktura kolejki:
 * {
 *   connection,
 *   player,
 *   songs: [{ title, url, requestedBy }],
 *   playing: boolean
 * }
 */

// 5️⃣ Funkcja odtwarzania
async function playSong(guildId) {
  const queue = queues.get(guildId);
  if (!queue) return;

  const next = queue.songs[0];
  if (!next) {
    console.log(`[${guildId}] 🎵 Kolejka pusta — zatrzymano.`);
    queue.playing = false;
    return;
  }

  try {
    console.log(`[${guildId}] ▶️ Odtwarzanie: ${next.title} (${next.url})`);
    const stream = await play.stream(next.url, { quality: 2 });
    const resource = createAudioResource(stream.stream, { inputType: stream.type });
    queue.player.play(resource);
    queue.playing = true;

    queue.player.once(AudioPlayerStatus.Idle, () => {
      console.log(`[${guildId}] ⏭️ Utwór zakończony: ${next.title}`);
      queue.songs.shift();
      playSong(guildId);
    });

    queue.player.once('error', err => {
      console.error(`[${guildId}] ⚠️ AudioPlayer error:`, err);
      queue.songs.shift();
      playSong(guildId);
    });
  } catch (err) {
    console.error(`[${guildId}] ❌ Błąd przy odtwarzaniu:`, err);
    queue.songs.shift();
    playSong(guildId);
  }
}

// 6️⃣ Logowanie bota
client.on('ready', () => {
  console.log(`✅ Zalogowano jako ${client.user.tag}`);
  console.log(generateDependencyReport());
});

// 7️⃣ Obsługa komend
client.on('messageCreate', async (message) => {
  if (message.author.bot || !message.guild) return;
  if (!message.content.startsWith(PREFIX)) return;

  const args = message.content.slice(PREFIX.length).trim().split(/ +/);
  const cmd = args.shift().toLowerCase();

  if (cmd === 'play') {
    const query = args.join(' ');
    if (!query) return message.reply('❗ Podaj link lub zapytanie wyszukiwania.');

    const voiceChannel = message.member.voice.channel;
    if (!voiceChannel) return message.reply('🔊 Wejdź najpierw na kanał głosowy.');

    const permissions = voiceChannel.permissionsFor(message.client.user);
    if (!permissions.has('Connect') || !permissions.has('Speak')) {
      return message.reply('🚫 Bot nie ma uprawnień do mówienia lub dołączenia.');
    }

    let queue = queues.get(message.guild.id);
    if (!queue) {
      const player = createAudioPlayer({ behaviors: { noSubscriber: NoSubscriberBehavior.Pause } });
      const connection = joinVoiceChannel({
        channelId: voiceChannel.id,
        guildId: message.guild.id,
        adapterCreator: message.guild.voiceAdapterCreator
      });
      queue = { connection, player, songs: [], playing: false };
      queues.set(message.guild.id, queue);
      connection.subscribe(player);
    }

    try {
      let songInfo;

      // 🎧 jeśli to link do YouTube
      if (play.yt_validate(query) === 'video') {
        const info = await play.video_info(query);
        songInfo = { title: info.video_details.title, url: info.video_details.url };
      } else {
        // 🔎 wyszukaj na YouTube
        const search = await play.search(query, { limit: 1 });
        if (!search || search.length === 0 || !search[0].url) {
          return message.reply('😔 Nie udało się znaleźć utworu na YouTube.');
        }
        songInfo = { title: search[0].title, url: search[0].url };
      }

      queue.songs.push({
        title: songInfo.title,
        url: songInfo.url,
        requestedBy: message.author.tag
      });

      message.reply(`🎶 Dodano do kolejki: **${songInfo.title}**`);

      if (!queue.playing) {
        playSong(message.guild.id);
      }
    } catch (err) {
      console.error('❌ Play command error:', err);
      message.reply('⚠️ Wystąpił błąd przy dodawaniu utworu.');
    }
  }

  // SKIP
  else if (cmd === 'skip') {
    const queue = queues.get(message.guild.id);
    if (!queue || queue.songs.length === 0) return message.reply('🕳️ Kolejka jest pusta.');
    queue.player.stop();
    message.reply('⏭️ Pominięto utwór.');
  }

  // STOP
  else if (cmd === 'stop') {
    const queue = queues.get(message.guild.id);
    if (!queue) return message.reply('❌ Bot nie gra niczego.');
    queue.songs = [];
    queue.player.stop();
    const conn = getVoiceConnection(message.guild.id);
    if (conn) conn.destroy();
    queues.delete(message.guild.id);
    message.reply('🛑 Bot zatrzymany i rozłączony.');
  }

  // QUEUE
  else if (cmd === 'queue') {
    const queue = queues.get(message.guild.id);
    if (!queue || queue.songs.length === 0) return message.reply('📭 Kolejka jest pusta.');
    const list = queue.songs
      .map((s, i) => `${i + 1}. ${s.title} (dodane przez ${s.requestedBy})`)
      .slice(0, 10)
      .join('\n');
    message.reply(`🎵 **Aktualna kolejka:**\n${list}`);
  }

  // PAUSE
  else if (cmd === 'pause') {
    const queue = queues.get(message.guild.id);
    if (!queue) return message.reply('⏸️ Nic nie jest odtwarzane.');
    queue.player.pause();
    message.reply('⏸️ Wstrzymano odtwarzanie.');
  }

  // RESUME
  else if (cmd === 'resume') {
    const queue = queues.get(message.guild.id);
    if (!queue) return message.reply('▶️ Nic nie jest wstrzymane.');
    queue.player.unpause();
    message.reply('▶️ Wznowiono odtwarzanie.');
  }

  // HELP
  else if (cmd === 'help') {
    message.reply(`
📘 **Dostępne komendy:**
\`\`\`
!play <link lub nazwa> — odtwarza muzykę
!skip — pomija bieżący utwór
!stop — zatrzymuje i rozłącza bota
!queue — pokazuje kolejkę
!pause — pauzuje
!resume — wznawia
!help — ta wiadomość
\`\`\`
    `);
  }
});

// 8️⃣ Obsługa błędów globalnych
process.on('unhandledRejection', err => console.error('UnhandledRejection:', err));
process.on('uncaughtException', err => console.error('UncaughtException:', err));

// 9️⃣ Start bota
client.login(TOKEN);
